# 로깅
### 로깅레벨
상위로 갈 수록 수치가 높고, 로그 출력시에는 해당 로그객체에 세팅된 로그레벨과 비교해서 그 이상의 로그레벨만 출력하여 CPU, 메모리, 파일 같은 자원을 아끼게 해 준다.

OFF : 로그 끔  (Integer.MAX_VALUE)  
FATAL : 크리티컬한 에러  
ERROR : 일반 에러  
WARN : 에러는 아니지만 주의 필요  
INFO : 일반 정보  
DEBUG : 일반 정보를 상세히.. (디버깅)  
TRACE : 경로추적을 위해 사용  
ALL : 모든 로그  (Integer.MIN_VALUE)  
```
log.setLevel(Level.WARN); //로그레벨 세팅

      log.trace("Trace Message!");
      log.debug("Debug Message!");
      log.info("Info Message!");
      log.warn("Warn Message!");
      log.error("Error Message!");
      log.fatal("Fatal Message!");
```
```
Warn Message!
Error Message!
Fatal Message!
```
JCL- 아파치(자카르타) 커먼스 로깅
```
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
...
private final Log log = LogFactory.getLog(this.getClass());
...
log.debug("count : " + count);
```
위와 같은 코드는 debug(String) 메소드를 실행하기 전에 파라미터 연산을 하게 한다.

문자열 연결(concatenation) 연산자 + 는 여러 문자열을 하나로 합치는 편리한 수단이지만, 성능상 문제가 있다.  
String 문자열은 변경 불가능하기 때문에, 문자열 두 개를 +로 연결할 때 그 두 문자열의 내용은 전부 복사되어 처리된다.  
n개의 문자열에 연결 연산자를 반복 적용해서 연결하는 데 드는 시간은 n제곱에 비례한다.  

로그 레벨이 error라면 위 내용을 파일로 찍지는 않겠지만 덧셈 연산은 다 하기에, 로그 양이 많고 트래픽이 많을 경우에는 성능차를 유발한다.  

JCL에서는, 성능에 민감해서 이것까지 차단하겠다면, 다음과 같은 코드를 사용하라고 가이드 했다. ('+'연산자때문에)
```
if (log.isDebugEnabled()){
    log.debug(... + ... + ... + ...);
}
```

## 스프링 부트 로깅
스프링 부트 프레임워크 자체의 소스는, JCL을 사용하여 로깅 코드를 작성했다.
스프링 부트 애플리케이션은 SLF4J를 사용한다. (개발자가 코딩시)  
스프링 부트 애플리케이션은 Logback을 사용한다. (개발자가 코딩시)  
원한다면 얼마든지 다른 로거를 사용할 수 있다. (개발자가 코딩시)  

### SLF4J
로깅추상화 라이브러리.  
JCL과 다른점은, JCL처럼 런타임시 클래스로더에의해서 찾는 방법이 아니라, 의존성정보로 판단한다.  
dependency를 참조하기때문에, 의존성정보를 잘 구성해야한다.
