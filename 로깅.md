# 로깅
### Log4j 로깅레벨
상위로 갈 수록 수치가 높고, 로그 출력시에는 해당 로그객체에 세팅된 로그레벨과 비교해서 그 이상의 로그레벨만 출력하여 CPU, 메모리, 파일 같은 자원을 아끼게 해 준다.

OFF : 로그 끔  (Integer.MAX_VALUE)  
FATAL : 크리티컬한 에러  
ERROR : 일반 에러  
WARN : 에러는 아니지만 주의 필요  
INFO : 일반 정보  
DEBUG : 일반 정보를 상세히.. (디버깅)  
TRACE : 경로추적을 위해 사용  
ALL : 모든 로그  (Integer.MIN_VALUE)  
```
log.setLevel(Level.WARN); //로그레벨 세팅

      log.trace("Trace Message!");
      log.debug("Debug Message!");
      log.info("Info Message!");
      log.warn("Warn Message!");
      log.error("Error Message!");
      log.fatal("Fatal Message!");
```
```
Warn Message!
Error Message!
Fatal Message!
```
특이사항으로는...
```
log.debug("count : " + count);
```
위와 같은 코드는 debug(String) 메소드를 실행하기 전에 파라미터 연산을 하게 한다.

문자열 연결(concatenation) 연산자 + 는 여러 문자열을 하나로 합치는 편리한 수단이지만, 성능상 문제가 있다.  
String 문자열은 변경 불가능하기 때문에, 문자열 두 개를 +로 연결할 때 그 두 문자열의 내용은 전부 복사되어 처리된다.  
n개의 문자열에 연결 연산자를 반복 적용해서 연결하는 데 드는 시간은 n제곱에 비례한다.  

로그 레벨이 error라면 위 내용을 파일로 찍지는 않겠지만 덧셈 연산은 다 하기에, 로그 양이 많고 트래픽이 많을 경우에는 성능차를 유발한다.

Log4J 에서는, 성능에 민감해서 이것까지 차단하겠다면, 다음과 같은 코드를 사용하라고 가이드 했다. ('+'연산자때문에)
```
if (log.isDebugEnabled()){
    log.debug(... + ... + ... + ...);
}
```
### SLF4J
로깅추상화 라이브러리.  
JCL과 다른점은, JCL처럼 런타임시 클래스로더에의해서 찾는 방법이 아니라, 의존성정보로 판단한다.  
dependency를 참조하기때문에, 의존성정보를 잘 구성해야한다.
