## 형상 관리 장점
- 소스코드 변경이력 관리
- 소스코드 공유
- 이전버전으로 복구
- 개발자간 버전 충돌 문제 관리
- 동일한 소프트웨어를 여러 개의 버전으로 분기하여 개발 가능

 

## 형상 관리 도구에서의 처리 방식
- Lock-Modify-Unlock방식
: 오직 한 명의 사용자가 파일을 읽고 쓸 수 있도록하고 작업이 완료되면 다른 사람에게 읽고 쓸 수 있는 권한을 주는 방식. 파일을 다른 사람이 사용하지 못하도록 잠금 처리를 한 상태에서 개발자들이 순차적으로 최신 버전을 다운받고 변경하고 반영. 다른사람의 작업이 완료될 때까지 작업할 수가 없어서 비효율적. 

- Copy-Modify-Merge 방식
: Lock을 걸지 않고, 일단 수정을 원하는 개발자가 모두 소스 코드를 다운로드해서 수정한 다음 형상 관리에 커밋을 하되 버전에 충돌이 생길 경우 머지 명령을 통해 통합해서 이를 해결한다. 개발자1,2가 동일한 소스코드르 받아서 각자 맡은 영역을 수정한 뒤, 먼저 형상관리에 반영하는 개발자는 문제없이 처리가 가능하지만, 그 이후 형상관리에 반영하는 개발자는 버전 충돌이 발생한다. 두 번째 개발자의 로컬에 있는 소스 코드의 형상관리 버전이 현재 형상관리에 있는 소스코드의 버전보다 낮기 때문이다. 이러한 문제를 해결하는 것이 머지 작업으로, 형상 관리에서 최신 소스 코드와 로컬 소스 코드를 병합하여 내려받고, 개발작업을 진행한 뒤, 형상관리에 반영한다. 머지작업시 실수로 문제를 발생시키는 경우가 있으며, 3명이상의 개발자가 동시작업시 머지 작업이 제대로 동작하지 않을 수도 있다.

## git
분산된 버전관리 시스템으로, 전체의 변경 히스토리와 내용을 각각의 사용자들 환경에 분산해서 관리하며 저장소가 중앙에 위치해 있긴 하지만, 개별 사용자의 로컬환경에도 있다.
이를 저장소를 복제한다고 표현한다. 그리고 관리되는 파일을 사용자들끼리 공유할 필요가 있을 경우에만 네트워크를 통해서 중앙 저장소에 반영한다.
그래서, git은 중앙의 형상관리 도구에 장애가 생겨도 개발 업무에 미치는 영향이 크지 않으며 형상 관리 속도 역시 매우 빠르다.

## Git 기본 용어
- 스냅샷 : Git에서 커밋할 때마다 발생하며 커밋한 시점의 형상관리 상태를 의미한다. 버전이라는 의미도 포함하고 있다.
- 트리 : 파일과 디렉터리의 구조 정보를 저장하고 있다. 일반적으로 파일 시스템이 트리 구조를 가지고 있기 때문에 형상 관리 역시 트리 형태로 스냅샷을 저장한다.
- 저작자(Author) : Git에서 관리하고 있는 파일 혹은 디렉터리를 최초로 생성한 사람의 정보이다. 일반적으로 사람을 식별할 수 있는 이름, 이메일 등의 정보를 저장한다.
- 커미터(Committer) : 최초 파일이 저장소에 반영되면 저작자와 커미터가 동일하지만, 이후 해당 파일을 다른 사람이 수정하게 되면 커미터가 변경된다. 그래서 저작자는 파일을 생성한 사람, 커미터는 파일을 변경한 사람으로 볼 수 있다.
- 커밋 메시지(Commit Message) : Git은 커밋할 때 반드시 커밋에 대한 메시지를 저장하도록 되어있다. 메시지들이 쌓이면 그 내용을 통해 소프트웨어의 개발히스토리를 확인할 수 있다.
- 부모커밋 : 현재 커밋이 참조하고 있는 상위 커밋을 의미한다. 최초 커밋 시에는 부모 커밋 객체가 없지만 이후 다시 커밋을 하게 되면 현재 커밋된 객체가 부모 커밋 객체가 되고 나중에 커밋한 객체가 커런트 객체가 된다. 일반적으로 소스 코드는 부모 커밋 객체가 없거나 하나만을 가지고 있지만 파일을 병합하는 경우 한 개 이상의 부모 객체를 가질 수 있다.

## Git의 3가지 영역
- 워킹 디렉터리 : 소스코드를 작업하는 영역으로, 코드를 추가, 수정, 삭제하는 작업이 이루어지는 영역을 의미한다.
- 스테이징 영역 : 워킹 디렉터리에서 git add 명령을 실행하면 파일들은 Git의 스테이징 영역으로 이동하며 이를통해 소스 코드의 상태 정보를 확인할 수 있다.
- 저장소 영역 : 스테이징 영역에 있는 소스 코드에 git commit 명령을 실행하면 최종적으로 Git의 저장소에 반영된다.

## 파일 관점에서의 4가지 단계
- Untracked : 워킹 디렉터리에 추가되었지만 Git에서 관리하지는 않는 상태
- Unmodified : 스테이징 영역에 기존에 Git에서 관리하지 않던 파일이 신규로 추가되었을 때의 상태. (= new file)
- Modified : 파일이 추가되있고, 스테이징 영역에 해당 파일이 수정되었을 떄의 상태.
- Staged : Git의 스테이징 영역에 반영된 상태.

## 스테이징영역으로의 반영 명령어
- git add (스테이징 영역에 추가)
- git rm (스테이징 영역에서 제거)

### 스테이징기능은 저장소에 반영하기 전에 검증할 수 있는 환경을 제공해 주어, 개발자 혹은 관리자의 실수로 저장소의 파일에 영향을 주는 것을 한번더 확인할 수 있는 기회를 준다.

## Git의 분산관리
Git에서의 원격 작업은 하나의 Git 저장소를 여러 서버에 동일하게 복제해서 활용하는 분산 관리를 의미한다.

Git 이전의 형상 관리 소프트웨어에서는 원격의 개발자들 간에 소스 코드를 공유하고 활용할 때 중앙 집중식을 이용했다.

중앙 집중식 형상 관리는 하나의 저장소에 전세계 개발자들이 접속해서 사용하는 방식으로 다음 문제점이 있다.

- 네트워크 환경이 멀리 있거나 느리다면 저장소의 정보를 가져오거나 로컬 소스를 커밋할 때 시간이 오래 걸린다.
- 중앙 저장소에 장애가 발생하면 모든 개발 작업이 중단된다.
- 중앙 저장소의 충분히 고사양이어야 한다.

소프트웨어 개발이 글로벌화하면서 전세계에 흩어져있는 연구소 혹은 지사 간에 소스 공유가 필요해졌는데 네트워크 속도가 느리거나 장애가 생겼을 때 중앙 집중식은 문제가 발생할 수밖에 없다.

이러한 문제를 해결하기 위해 Git은 저장소를 분산시키고 이를 다시 중앙에 취합하는 형태를 취하고 있다.

분산형 형상 관리 소프트웨어의장점

- 개발자가 로컬 형상 관리 저장소에서 작업하기 때문에 네트워크로 인한 속도 저하 문제가 발생하지 않는다.
- 중앙 저장소에 장애가 발생해도 지역 저장소에는 영향이 없기 때문에 개발 작업에는 영향이 거의 없다.
- 잦은 변경은 지역 저장소를 대상으로 하고 최종 변경분은 중앙과 동기화해서 관리한다.

이렇게 분산화 시키면 개발 효율을 높일 수 있고, 특정 저장소의 장애로 인해 전체 개발 업무에 미치는 영향을 최소화할 수 있다.
형상 관리 서버 사양 역시, 지역을 서비스할 수있는 정도의 용량만 확보학면 되기 떄문에 상대적으로 저사양 서버로도 충분히 서비스가 가능하다.
