## 형상 관리 장점
- 소스코드 변경이력 관리
- 소스코드 공유
- 이전버전으로 복구
- 개발자간 버전 충돌 문제 관리
- 동일한 소프트웨어를 여러 개의 버전으로 분기하여 개발 가능

 

## 형상 관리 도구에서의 처리 방식
- Lock-Modify-Unlock방식
: 오직 한 명의 사용자가 파일을 읽고 쓸 수 있도록하고 작업이 완료되면 다른 사람에게 읽고 쓸 수 있는 권한을 주는 방식. 파일을 다른 사람이 사용하지 못하도록 잠금 처리를 한 상태에서 개발자들이 순차적으로 최신 버전을 다운받고 변경하고 반영. 다른사람의 작업이 완료될 때까지 작업할 수가 없어서 비효율적. 

- Copy-Modify-Merge 방식
: Lock을 걸지 않고, 일단 수정을 원하는 개발자가 모두 소스 코드를 다운로드해서 수정한 다음 형상 관리에 커밋을 하되 버전에 충돌이 생길 경우 머지 명령을 통해 통합해서 이를 해결한다. 개발자1,2가 동일한 소스코드르 받아서 각자 맡은 영역을 수정한 뒤, 먼저 형상관리에 반영하는 개발자는 문제없이 처리가 가능하지만, 그 이후 형상관리에 반영하는 개발자는 버전 충돌이 발생한다. 두 번째 개발자의 로컬에 있는 소스 코드의 형상관리 버전이 현재 형상관리에 있는 소스코드의 버전보다 낮기 때문이다. 이러한 문제를 해결하는 것이 머지 작업으로, 형상 관리에서 최신 소스 코드와 로컬 소스 코드를 병합하여 내려받고, 개발작업을 진행한 뒤, 형상관리에 반영한다. 머지작업시 실수로 문제를 발생시키는 경우가 있으며, 3명이상의 개발자가 동시작업시 머지 작업이 제대로 동작하지 않을 수도 있다.

## git
분산된 버전관리 시스템으로, 전체의 변경 히스토리와 내용을 각각의 사용자들 환경에 분산해서 관리하며 저장소가 중앙에 위치해 있긴 하지만, 개별 사용자의 로컬환경에도 있다.
이를 저장소를 복제한다고 표현한다. 그리고 관리되는 파일을 사용자들끼리 공유할 필요가 있을 경우에만 네트워크를 통해서 중앙 저장소에 반영한다.
그래서, git은 중앙의 형상관리 도구에 장애가 생겨도 개발 업무에 미치는 영향이 크지 않으며 형상 관리 속도 역시 매우 빠르다.

## Git 기본 용어
- 스냅샷 : Git에서 커밋할 때마다 발생하며 커밋한 시점의 형상관리 상태를 의미한다. 버전이라는 의미도 포함하고 있다.
- 트리 : 파일과 디렉터리의 구조 정보를 저장하고 있다. 일반적으로 파일 시스템이 트리 구조를 가지고 있기 때문에 형상 관리 역시 트리 형태로 스냅샷을 저장한다.
- 저작자(Author) : Git에서 관리하고 있는 파일 혹은 디렉터리를 최초로 생성한 사람의 정보이다. 일반적으로 사람을 식별할 수 있는 이름, 이메일 등의 정보를 저장한다.
- 커미터(Committer) : 최초 파일이 저장소에 반영되면 저작자와 커미터가 동일하지만, 이후 해당 파일을 다른 사람이 수정하게 되면 커미터가 변경된다. 그래서 저작자는 파일을 생성한 사람, 커미터는 파일을 변경한 사람으로 볼 수 있다.
- 커밋 메시지(Commit Message) : Git은 커밋할 때 반드시 커밋에 대한 메시지를 저장하도록 되어있다. 메시지들이 쌓이면 그 내용을 통해 소프트웨어의 개발히스토리를 확인할 수 있다.
- 부모커밋 : 현재 커밋이 참조하고 있는 상위 커밋을 의미한다. 최초 커밋 시에는 부모 커밋 객체가 없지만 이후 다시 커밋을 하게 되면 현재 커밋된 객체가 부모 커밋 객체가 되고 나중에 커밋한 객체가 커런트 객체가 된다. 일반적으로 소스 코드는 부모 커밋 객체가 없거나 하나만을 가지고 있지만 파일을 병합하는 경우 한 개 이상의 부모 객체를 가질 수 있다.

## Git의 3가지 영역
- 워킹 디렉터리 : 소스코드를 작업하는 영역으로, 코드를 추가, 수정, 삭제하는 작업이 이루어지는 영역을 의미한다.
- 스테이징 영역 : 워킹 디렉터리에서 git add 명령을 실행하면 파일들은 Git의 스테이징 영역으로 이동하며 이를통해 소스 코드의 상태 정보를 확인할 수 있다.
- 저장소 영역 : 스테이징 영역에 있는 소스 코드에 git commit 명령을 실행하면 최종적으로 Git의 저장소에 반영된다.

## 파일 관점에서의 4가지 단계
- Untracked : 워킹 디렉터리에 추가되었지만 Git에서 관리하지는 않는 상태
- Unmodified : 스테이징 영역에 기존에 Git에서 관리하지 않던 파일이 신규로 추가되었을 때의 상태. (= new file)
- Modified : 파일이 추가되있고, 스테이징 영역에 해당 파일이 수정되었을 떄의 상태.
- Staged : Git의 스테이징 영역에 반영된 상태.

## 스테이징영역으로의 반영 명령어
- git add (스테이징 영역에 추가)
- git rm (스테이징 영역에서 제거)

### 스테이징기능은 저장소에 반영하기 전에 검증할 수 있는 환경을 제공해 주어, 개발자 혹은 관리자의 실수로 저장소의 파일에 영향을 주는 것을 한번더 확인할 수 있는 기회를 준다.

## Git의 분산관리
Git에서의 원격 작업은 하나의 Git 저장소를 여러 서버에 동일하게 복제해서 활용하는 분산 관리를 의미한다.

Git 이전의 형상 관리 소프트웨어에서는 원격의 개발자들 간에 소스 코드를 공유하고 활용할 때 중앙 집중식을 이용했다.

중앙 집중식 형상 관리는 하나의 저장소에 전세계 개발자들이 접속해서 사용하는 방식으로 다음 문제점이 있다.

- 네트워크 환경이 멀리 있거나 느리다면 저장소의 정보를 가져오거나 로컬 소스를 커밋할 때 시간이 오래 걸린다.
- 중앙 저장소에 장애가 발생하면 모든 개발 작업이 중단된다.
- 중앙 저장소의 충분히 고사양이어야 한다.

소프트웨어 개발이 글로벌화하면서 전세계에 흩어져있는 연구소 혹은 지사 간에 소스 공유가 필요해졌는데 네트워크 속도가 느리거나 장애가 생겼을 때 중앙 집중식은 문제가 발생할 수밖에 없다.

이러한 문제를 해결하기 위해 Git은 저장소를 분산시키고 이를 다시 중앙에 취합하는 형태를 취하고 있다.

분산형 형상 관리 소프트웨어의장점

- 개발자가 로컬 형상 관리 저장소에서 작업하기 때문에 네트워크로 인한 속도 저하 문제가 발생하지 않는다.
- 중앙 저장소에 장애가 발생해도 지역 저장소에는 영향이 없기 때문에 개발 작업에는 영향이 거의 없다.
- 잦은 변경은 지역 저장소를 대상으로 하고 최종 변경분은 중앙과 동기화해서 관리한다.

이렇게 분산화 시키면 개발 효율을 높일 수 있고, 특정 저장소의 장애로 인해 전체 개발 업무에 미치는 영향을 최소화할 수 있다.
형상 관리 서버 사양 역시, 지역을 서비스할 수있는 정도의 용량만 확보학면 되기 떄문에 상대적으로 저사양 서버로도 충분히 서비스가 가능하다.

## Git Hub 저장소 관리 명령어
- 원격저장소 -> 로컬저장소로 복제 : git clone https://~~~.git
- 로컬저장소 -> 원격저장소로 동기화 : git push
- 원격저장소의 변경정보를 내려받기 (로컬저장소의 것과 비교만을 목적으로 함) : git fetch
- fetch로 받은 원격저장소의 변경정보를 로컬의 것과 비교 : git status
- 원격저장소 -> 로컬저장소로 동기화 : git pull
- 로컬저장소 -> 원격저장소로 복제 : git remote add origin https://~~~.git

## 서브버전
Git은 분산된 팀과 분산된 부서가 활용할때 효과가 크지만,프로젝트 구조가 중앙집중적이고 한 곳에 모두 모여서 작업을 한다면 Git을 사용하는 효과가 크지 않다.
이러한 점들을 고려했을 때, Git에게 자리를 점차 내주고 있지만 여전히 서브버전의 매력이 있다.

## 서브버전의 장점
- 리비전 개념 : 전체 프로젝트 레벨, 달리 말하면 서브버전의 저장소 레벨의 리비전(저장소의 특정 시점을 기준으로 함)개념으로 버전 정보를 관리한다. 레파지터리에 있는 어떤 형상이라도 변경되면, 모든 형상의 리비전이 증가. 해당 소스의 리비전 번호만 있으면, 해당소스가 커밋될 때의 모든 형상을 찾을 수가 있다.
- Copy-Modify-Merge : 파일 Lock 기능을최소화하고 파일을 각자수정한 후 통합하는 형태의 프로세스를 제공한다.

서브버전이 나오기 전에 형상 관리 소프트웨어로 유명한 CVS는 각 파일 및 디렉터리에 개별적인 버전을 부여해서 관리했는데, 이 것은 특정한 시점의 버전으로 전체소스 코드를 되돌리는 데에 한계가 있고, 전체 프로젝트에 대한 브랜치 처리나 태깅 처리 등에 제약이 많았다. 서브버전은 기존 형상 관리 문제를 해결하기 위해 리비전 개념을 적용하여 특정 시점 소스 코드의 형상 및 상태를 관리할 수 있게 되었다.

## 서브버전으로 형상관리
Git과 서브버전의 차이는 Git은 저장소를 복제해서 사용하지만 서브버전은 그러한 과정 없이 원하는 프로젝트르 로컬로 내려받아서 작업한 후 이를 다시 서브버전에 직접 반영하는 형태를 취한다는 점이다.
서브버전으로 형상 관리를 연계하는 단위는 다음과 같다.
- import : 최초 서브버전 저장소에 소스 코드를 업로드 한다.
- checkout : 서브버전의 소스 코드를 내려받는다.
- commit : 체크아웃한 소스코드나 신규 생성한 소스 코드를 서브버전에 반영하는 작업으로 체크인과 동일하게 사용한다.
- update : 다른 사용자가 서브버전에 반영한 내용을 로컬에 업데이트 받는다.

import만 프로젝트를 생성할 때 처음 발생하고 나머지 checkout-commit-update는 여러 개발자들이 반복적으로 수행하는 작업이다.

## 서브버전의 수 디렉터리
- trunk : 형상 관리할 파일이 저장되는 위치이다. 여기에 프로젝트의 메인 소스코드들이 위치한다.
- branches : trunk에정의된 특정 리비전을 기준으로 브랜치를 만드는곳이다. 주로 메인 프로그램을 기반으로 특정한 요건이나 환경을위한 프로그램을 만들 때 사용한다.
- tags : 특정 리비전에 사람들이 쉽게 이해할 수 있는 문자로 태그를 붙이는 작업.

```
Repositories - Project A - trunk
	     	         - branch
	                 - tags
```

## 브랜치와 머지
과거 많이 사용한 CVS를 서브버전이 빠르게 대체하게 된 이 중 하나가 브랜치 기능이다. 사실 형상 관리를 사용하면서 브랜치 기능을 사용하는 경우는 많지 않다.
- 하나의 프로젝트에서 파생되어 관리해야 하는 프로젝트들이 존재할 경우
- 이미 만들어서 운영중인 소프트웨어를 특정 국가, 특정 요구 상항에 맞게 변경해야 할 경우
하나의 메인 프로젝트에서 파생된 프로젝트를 관리할 경우 별도의 서브버전 저장소를 분리해서 관리하는것이 아니라, 메인프로젝트를 기반으로 브랜치를 만들어서 수정하고 메인 프로젝트가 변경되면 다시 브랜치 프로젝트에 반영해서 개발하는 방식으로 진행한다.
이렇게 필요에 따라서 생성한 브랜치를 다시 메인프로젝트와 통합하거나 메인 프로젝트의 변경 내용을 다시 브랜치에 반영하는 작업을 머지라고 한다.

